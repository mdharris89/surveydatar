% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/surveymetadatafunctions.R
\name{split_into_question_groups}
\alias{split_into_question_groups}
\title{split_into_question_groups
key part of create_dict_with_metadata
attempts to find a $question within a temp_dpdict with a unique suffix in an attempt to group variables into sensible questions
(will work within existing question groups if $question already exists, else will create starting $question from prefix to variable_name_sep)
will also provide a column question_lcs which is the longest common string found within a question group (this is used to define question groups when splitbycommonlabel == TRUE)}
\usage{
split_into_question_groups(
  temp_dpdict,
  temp_dat,
  variable_name_sep = "_",
  ignorelabelbeforeprefix = TRUE,
  prefix_sep = ": ",
  splitbyclass = TRUE,
  splitbynumlabelledvalues = TRUE,
  splitbynoncontiguous = TRUE,
  splitbycommonlabel = TRUE,
  labelsep = " - ",
  findlongest = FALSE,
  min_lcs_length = 10,
  min_common_strings = 5,
  consistent_consecutive_mode = FALSE,
  variable_compare_mode = "reduced",
  consecutive_range = 10,
  noisy = 0
)
}
\arguments{
\item{temp_dpdict}{dpdict for temp_dat. must have question_group variable.}

\item{temp_dat}{survey data dataframe}

\item{variable_name_sep}{"\emph{" by default. string that separates each variable within a common question, e.g. if Q1_1, Q1_2 "}" is the correct variable_name_sep.}

\item{ignorelabelbeforeprefix}{boolean. if true, removes substring before prefix_sep before working with variable labels}

\item{prefix_sep}{string. if ignorelabelbeforeprefix == TRUE, the substring before prefix_sep will be removed before working with variable labels .}

\item{splitbyclass}{boolean. if true, every successive new class is given a new unique suffix}

\item{splitbynumlabelledvalues}{boolean. if true, each variable with a different number of labelled values is given a new unique suffix (because we would expect multiple variables in the same question to have the same number of options, e.g. battery of likert scales)}

\item{splitbynoncontiguous}{boolean. if true, variables with the same variable name prefix that are not located adjacent to each other are given a new unique suffix}

\item{splitbycommonlabel}{boolean. if true, each variable for which the longest common string within the variable label for that variable does not match the longest common string within the question group as a whole, is given a new suffix}

\item{labelsep}{string. setting for when findlongest == FALSE, in which case uses the substring in the variable name prior to labelsep as commonlabel.}

\item{findlongest}{boolean. if true, applies splitbycommonlabel by looking for the longest common substring. (this is computationally expensive.) if false, takes substring preceding labelsep as the commonlabel.}

\item{min_lcs_length}{integer. any potential lcs shorter than min_lcs_length is disqualified.}

\item{min_common_strings}{integer. setting for when findlongest == TRUE. looks for substrings common to at least min_common_strings other variables in the question group and will take from this subset the longest string.}

\item{consistent_consecutive_mode}{boolean. if true, will look for strings common with consecutive variables within consecutive_range. this is intended to speed up finding the best lcs. but it's not always useful as it can be too sensitive to spurious lcs. not used by default. instead, if consistent_consecutive_mode == FALSE, it will look for strings common to at least min_common_strings other variables in the question group.}

\item{variable_compare_mode}{either "complete" or "reduced'. setting for when findlongest == TRUE. "complete" is computationally cheaper. if "complete", compares within the entire question group to find lcs for each statement. if "reduced", only looks at the variables before and after the variable in question, according to consecutive_range (a parameter in split_into_question_groups)}

\item{consecutive_range}{integer. if variable_compare_mode == "reduced", only looks at the variables consecutive_range before and after the variable in question.}

\item{noisy}{numeric. noisy == 0 by default. if == 1, 2, 3 or 4 will do varying levels of printing for debugging and monitoring}
}
\value{
temp_dpdict with question groups split according to the function settings
}
\description{
note: if last variable in a question in returned dict just keeps its full string, min_common_strings may be set too high
}
\details{
requires letters_702
}
\examples{
temp_dat <- get_big_test_dat(n=10)
temp_dpdict <- create_dict(temp_dat, prefill = TRUE) # create fresh basic dpdict
# but we don't need variables for 'old' names and labels
temp_dpdict <- temp_dpdict[, !(names(temp_dpdict) \%in\% c("old_variable_names",
                                                   "old_variable_labels",
                                                   "old_value_labels"))]
temp_dpdict <- split_into_question_groups(temp_dpdict, temp_dat, variable_name_sep = "_",
                                       ignorelabelbeforeprefix = TRUE, prefix_sep = ": ",
                                       splitbyclass = TRUE, splitbynumlabelledvalues = TRUE,
                                       splitbynoncontiguous = TRUE,
                                       splitbycommonlabel = TRUE, labelsep = " - ",
                                       findlongest = TRUE, min_lcs_length = 10,
                                       min_common_strings = 5,
                                       consistent_consecutive_mode = FALSE,
                                       consecutive_range = 10,
                                       variable_compare_mode = "reduced",
                                       noisy = 0)
}
