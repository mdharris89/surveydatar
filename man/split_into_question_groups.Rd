% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/surveymetadatafunctions.R
\name{split_into_question_groups}
\alias{split_into_question_groups}
\title{split_into_question_groups}
\usage{
split_into_question_groups(
  temp_dpdict,
  temp_dat,
  variables_to_process = NULL,
  seps_to_use = list(),
  ignorelabelbeforeprefix = TRUE,
  config = list(),
  noisy = 0
)
}
\arguments{
\item{temp_dpdict}{A dpdict data frame. Must contain 'variable_names' and
'variable_labels'. A 'question_group' column will be created if it
doesn't exist (based on variable names before \code{var_name_sep})}

\item{temp_dat}{The corresponding survey data dataframe.}

\item{variables_to_process}{Optional logical vector (length = nrow(temp_dpdict))
indicating which variables to process. If NULL (default), all are processed.
Note: If any variable in a group is selected, all variables in that
original group will be processed}

\item{seps_to_use}{List specifying separators used for parsing names/labels.
Defaults are used if not provided. See \code{\link{check_seps}}. Key elements:
'var_name_sep', 'prefix_sep', 'statement_sep'.}

\item{ignorelabelbeforeprefix}{Logical. If TRUE, removes substring before prefix_sep before working with variable labels.}

\item{config}{Optional list with configuration settings. Can include:
- splitbyclass: Logical. If TRUE, every successive new class is given a new unique suffix.
- splitbynumlabelledvalues: Logical. If TRUE, each variable with a different number of labelled values gets a new suffix.
- splitbynoncontiguous: Logical. If TRUE, variables with the same variable name prefix not located adjacent are given a new suffix.
- splitbycommonlabel: Logical. If TRUE, each variable with a different longest common string gets a new suffix.
- splitbylabelvalues: Logical. If TRUE, each variable with different actual label values gets a new suffix (exact match required, including order). Default FALSE.
- findlongest: Logical. If TRUE, finds longest common substring (computationally expensive).
- min_lcs_length: Integer. Any potential lcs shorter than this is disqualified.
- min_common_strings: Integer. For findlongest == TRUE, looks for substrings common to at least this many variables.
- consistent_consecutive_mode: Logical. If TRUE, look for strings common with consecutive variables.
- consecutive_range: Integer. For variable_compare_mode == "reduced", only looks at variables this many before and after.
- variable_compare_mode: String. Either "complete" or "reduced" - affects how variables are compared.}

\item{noisy}{Integer 0-4 controlling verbosity level.}
}
\value{
The input \code{temp_dpdict} data frame with updated 'question_group'
and 'question_lcs' columns
}
\description{
attempts to find a $question_group within a temp_dpdict with a unique suffix that groups variables into sensible questions
}
\details{
key function for defining survey metadata (e.g. as part of create_dict_with_metadata)
will work within existing question groups if $question_group already exists, else will create starting $question_group from prefix to var_name_sep
will also provide a column question_lcs which is the longest common string found within a question group (this is used to define question groups when splitbycommonlabel == TRUE)

note: if last variable in a question in returned dict just keeps its full string, min_common_strings may be set too high

Iterates through initial question groups and applies splitting rules
based on the \code{config} settings. A new group (with a new suffix like "_b")
is started whenever a condition is met for consecutive variables within the
original group.

Default \code{config} settings:
\itemize{
\item \code{splitbyclass = TRUE}: Split if variable class changes.
\item \code{splitbynumlabelledvalues = TRUE}: Split if the number of defined value labels changes.
\item \code{splitbynoncontiguous = TRUE}: Split if variables with the same original prefix are not adjacent in the \code{dpdict}.
\item \code{splitbycommonlabel = TRUE}: Split if the common part of the variable label changes. How the "common part" is determined depends on \code{findlongest}.
\item \code{splitbylabelvalues = FALSE}: Split if the actual label values differ (requires exact match including order). Off by default for performance.
\item \code{findlongest = FALSE}: If FALSE (default) and \code{splitbycommonlabel=TRUE}, the common label is assumed to be the text before \code{statement_sep}. If TRUE, the function actively searches for the Longest Common Substring (LCS) between labels, which is much slower.
\item \code{min_lcs_length = 10}: Minimum length for a string to be considered a potential LCS when \code{findlongest=TRUE}.
\item \code{min_common_strings = 5}: When \code{findlongest=TRUE}, requires an LCS candidate to be common to at least this many variables in the group to be prioritized.
\item \code{consistent_consecutive_mode = FALSE}: Alternative LCS finding logic (experimental/unused by default).
\item \code{consecutive_range = 10}: Range for comparing variables in 'reduced' mode.
\item \code{variable_compare_mode = "reduced"}: How variables are compared when \code{findlongest=TRUE} ("complete" or "reduced").
}
Finding the LCS (\code{findlongest = TRUE}) uses \code{\link{get_longest_common_substring}}.
Note: If the last variable in a group retains its full label as \code{question_lcs}, \code{min_common_strings} might be set too high.
}
\examples{
temp_dat <- get_big_test_dat(n=10)
temp_dpdict <- create_dict(temp_dat, prefill = TRUE)
temp_dpdict <- temp_dpdict[, !(names(temp_dpdict) \%in\% c("old_variable_names",
                                                   "old_variable_labels",
                                                   "old_value_labels"))]
# basic usage
temp_dpdict <- split_into_question_groups(temp_dpdict, temp_dat,
                                         seps_to_use = list(var_name_sep = "_",
                                         prefix_sep = ": ", statement_sep = " - "))

# usage with custom configuration
config <- list(
  splitbyclass = TRUE,
  splitbycommonlabel = TRUE
)
temp_dpdict <- split_into_question_groups(temp_dpdict, temp_dat,
                                         seps_to_use = list(var_name_sep = "_",
                                         prefix_sep = ": ", statement_sep = " - "),
                                         config = config)
}
