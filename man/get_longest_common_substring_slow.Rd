% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/surveymetadatafunctions.R
\name{get_longest_common_substring_slow}
\alias{get_longest_common_substring_slow}
\title{get_longest_common_substring_slow}
\usage{
get_longest_common_substring_slow(
  string1,
  string2,
  lcs_mode = "complete",
  increments_mode = "backward",
  stopping_threshold = 3,
  starting_string = NULL,
  noisy = FALSE
)
}
\arguments{
\item{string1}{a string}

\item{string2}{another string}

\item{lcs_mode}{either "complete", "starting_string_priority" or "starting_string_only".
if lcs_mode == "complete" will, for each starting position in string1, attempt to successively add characters to find the longest possible match.
if lcs_mode == "starting_string_priority" will look for a match in starting string first...
\enumerate{
\item if starting_string is a match in both, will try extending starting string to find a longer lcs. if not found, will assume starting_string is lcs. (i.e. doesn't look for an alternative lcs)
\item if starting_string is not a match in both, will try from next starting location in starting_string (i.e. removing the first character), and then attempt (1) above
\item if still no match, will revert to "complete" above (though checking so as to not repeat checks already made)
if match found within starting_string, superset or subset of starting_string, will finish early, i.e. won't look for a longer lcs outside starting_string
if lcs_mode == "starting_string_only" will only look for a match in starting string.
}}

\item{increments_mode}{"forward", "backward", or "random".
if increments == "forward" will add characters successively and check match each time.
if increments == "random" will randomise number of characters to add each time, without replacement, bounded by min(nchar(string1), nchar(string2) - so should be faster for longer strings.}

\item{stopping_threshold}{integer. if iterations since last improvement in lcs exceeds stopping_threshold, returns best lcs so far.}

\item{starting_string}{string to start with if lcs_mode is starting_string_priority or starting_string_only}

\item{noisy}{boolean. if true, prints status messages.}
}
\value{
substring which represents the longest common starting substring found between string1 and string2, with an attribute lcs_distance representing the number of characters in the lcs
}
\description{
an old implementation of getting the longest common substring. about 3x slower than get_longest_common_substring()
}
\examples{
get_longest_common_substring_slow("boat", "boar")
}
